---
title: "Non-overlapping Windows Analysis"
---

```{r nowsetup, include=FALSE}
write.table(c("",
              "####################################",
              "####        NOW Simulation      ####",
              "####################################"),
            file=fn_log, quote=F, row.names=F, col.names=F, append=T)

window_outdir <- paste(getwd(), "/windows/", sep="")
if (!file.exists(window_outdir)) {
  dir.create(window_outdir, recursive = T)
}

if (length(params$window_size) == 0) {
  log4r::error(fn_logger, "Error: window size is not specified. Exited.")
  knitr::knit_exit()
}

fn_alisim <- paste(getwd(), "/simulation/", params$prefix, ".fa", sep="")
fn_uqtops <- paste(getwd(), "/simulation/", params$prefix, ".uqtops", sep="")
```

```{r nowalignment, include=FALSE}
options(scipen=999)

# read fasta file
s <- read.fasta(fn_alisim, whole.header = T)
lens <- getLength(s)[1]

# iterate through window sizes
for (w in params$window_size) {
  if (w == 0) {
    log4r::warn(fn_logger, "Warning: window size cannot be zero. Skipped.")
    next
  }
  
  temp_outdir <- paste(window_outdir,w,"/alignment/",sep="")
  if (!file.exists(temp_outdir)) {
    dir.create(temp_outdir, recursive = T)
  }
  
  if (length(list.files(temp_outdir, pattern='fa')) != 0 && !params$redo) {
    log4r::info(fn_logger, paste0("File already exists: ", w, "bp window alignment. Skipped.", sep=""))
    next
  } 
  
  # remove all alignments in the folder
  unlink(paste0(temp_outdir,"*.fa"))
  
  # generate window alignments
  start <- 1
  wi <- floor(log(floor(lens/w)) / log(10)) + 1
  
  for (i in 1:floor(lens/w)) {
    subfasta <- lapply(s, function(x) x[seq(from = start, to = as.numeric(i*w))])
    df <- do.call(rbind,subfasta)
      
    subfasta <- setNames(split(df, seq(nrow(df))), rownames(df))
    write.fasta(sequences=subfasta, names=names(subfasta),
                file.out=paste(temp_outdir,"window_",formatC(i,width=wi,format="d",flag="0"),".fa",sep=""),
                nbchar = 100)
      
    start <- start + w
  }
  
  log4r::info(fn_logger, paste0("File created: ", w, "bp window alignment.", sep=""))
}
```

```{r nowtree, include=FALSE}
window_sizes <- list.dirs(window_outdir, full.names = F, recursive = F)

# iterate through window sizes
for (i in window_sizes) {
  temp_outdir <- paste(window_outdir,i,"/trees/",sep="")
  if (!file.exists(temp_outdir)) {
    dir.create(temp_outdir, recursive = T)
  }
  
  if (length(list.files(temp_outdir,pattern='treefile')) != 0 && !params$redo) {
    log4r::info(fn_logger, paste0("File already exists: ", i, "bp window treefile. Skipped.", sep=""))
    next
  }
  
  # generate window treefile
  fastadir <- paste(window_outdir,i,"/alignment/",sep="")
  prefix <- paste(temp_outdir,params$prefix,sep="")

  if (is.null(params$outgroup) || params$outgroup == ""){
    system(paste(params$iqtree2dir,"-S",fastadir,"-m",params$alisim_model,"-pre",prefix,"--quiet -redo", sep=" "))
  } else {
    system(paste(params$iqtree2dir,"-S",fastadir,"-m",params$alisim_model,"-pre",prefix,"--quiet -redo -o",params$outgroup, sep=" "))
  }
  
  log4r::info(fn_logger, paste0("File created: ", i, "bp window treefile.", sep=""))
}
```

```{r nowsummary, include=FALSE}
options(scipen=999)

# read unique topology files
t_hash <- hash()
t_count <- 1

topology_file <- file(description=fn_uqtops, open="r", blocking = TRUE)
while (length(tl <- readLines(topology_file, n=1, warn=F))) {
  tl <- write.tree(unroot(read.tree(text=tl)))
  t_hash[tl] = paste("T", t_count, sep="")
  t_count <- t_count + 1
}
close(topology_file)

# iterate through window sizes
for (i in window_sizes) {
  temp_outdir <- paste(window_outdir,i,"/summary/",sep="")
  if (!file.exists(temp_outdir)) {
    dir.create(temp_outdir, recursive = T)
  }
  
  fn_atsum <- paste(temp_outdir, params$prefix, ".atsum", sep="")
  fn_atsumf <- paste(temp_outdir, params$prefix, ".atsum.tiff", sep="")
  fn_cnsum <- paste(temp_outdir, params$prefix, ".cnsum", sep="")
  fn_cnsumf <- paste(temp_outdir, params$prefix, ".cnsum.tiff", sep="")
  fn_tops <- paste(temp_outdir, params$prefix, ".topsum", sep="")
  if (all(file.exists(fn_atsum, fn_atsumf, fn_cnsum, fn_cnsumf, fn_tops)) && !params$redo) {
    log4r::info(fn_logger, paste0("Files already exist: ", i, "bp window summary files. Skipped.", sep=""))
    next
  }
  
  # retrieve each fasta file and its respective topology
  seq_list <- sort(list.files(paste(window_outdir, i, "/alignment/", sep="")))
  iqtree_file <- file(description = paste(window_outdir, i, "/trees/", params$prefix, ".treefile", sep=""), open="r", blocking = TRUE)
  
  seq_len <- data.frame(stringsAsFactors = FALSE)
  start <- 0
  
  while (length(trl <- readLines(iqtree_file, n=1))) {
    ttop <- "NT"
    tl <- read.tree(text=trl)
    tl$edge.length <- NULL
    tree <- write.tree(tl)
    
    for (j in names(t_hash)) {
      if (all.equal.phylo(read.tree(text = j), tl)) {
        ttop <- as.character(t_hash[[j]])
        break
      }
    }
    
    # store the values in dataframe
    pl <- seq_list[start/as.numeric(i)+1]
    seq_len <- rbind(seq_len, c(pl,start+1,start+as.numeric(i),as.numeric(i),tree, ttop))
    
    start <- start+as.numeric(i)
  }
  close(iqtree_file)
  colnames(seq_len) <- c("source", "start", "stop", "length", "newick", "topology")
  
  # extract essential columns
  dat <- do.call(rbind, apply(seq_len, 1, 
                               function(x) data.table(bp = x["start"]:x["stop"], topology = x["topology"])))
  
  # visualization of topology switching across chromosome
  tiff(file=fn_atsumf, units="px", width=250, height=2000)
  print(ggplot() +
    geom_rect(data=dat,aes(fill=topology,ymin=0,ymax=bp,xmin=0,xmax=1)) +
    labs(x=paste(i,"bp")) +
    theme_void() +
    theme(
      axis.text.y=element_text(size=20),
      legend.text=element_text(size=20),
      legend.key.size=unit(2,"cm")
      ))
  dev.off()
  
  write.table(seq_len, fn_atsum, quote=F, sep="\t", row.names=F, col.names=T)
  log4r::info(fn_logger, paste0("Files created: ", i, "bp annotation summary files (",
                               params$prefix, ".atsum and ", params$prefix, ".atsum.tiff).", sep=""))
  
  # extract top topologies
  top_tops <- seq_len %>% 
    group_by(newick) %>% 
    summarise(count = n()) %>% 
    arrange(desc(count)) %>%
    mutate(cum.percentage = round(cumsum(count)/nrow(seq_len),3))
  
  write.table(top_tops, fn_tops, quote=F, sep="\t", row.names=F, col.names=T)
  log4r::info(fn_logger, paste0("File created: ", i, "bp top topology file (", params$prefix, ".topsum).", sep=""))
  
  # count consecutive/contiguous windows per topology
  count_contiguous <- seq_len %>% 
    group_by(topology,
             group_run = data.table::rleid(topology)) %>% 
    summarise(count = n()) %>% 
    arrange(group_run)
  count_contiguous$group_run <- NULL
  
  cons_windows <- count_contiguous %>%
    group_by(topology, count) %>%
    summarise(total = n())
  
  tiff(filename=fn_cnsumf, units="px", width=2880, height=1800)
  print(ggplot(cons_windows, aes(fill=topology)) + 
        geom_bar(position="dodge", stat="identity", aes(y=total, x=count)) +
        aes(x = fct_inorder(topology)) +
        ggtitle("Distribution of Consecutive Windows Per Topology") + 
        facet_grid(~topology) +
        theme(
          plot.title = element_text(hjust = 0.5, size = 50),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_text(size=30),
          axis.text.x=element_text(size=30),
          legend.title=element_blank(),
          legend.text=element_text(size=30),
          legend.key.size=unit(2,"cm")
        ))
  dev.off()
  
  write.table(count_contiguous, fn_cnsum, quote=F, row.names=F)
  log4r::info(fn_logger, paste0("Files created: ", i, "bp consecutive summary files (",
                               params$prefix, ".cnsum and ", params$prefix, ".cnsum.tiff).", sep=""))
}
```

```{r nowcontiguous, include=FALSE}
sdf <- do.call(rbind,s)

# iterate through window sizes
for (i in window_sizes) {
  temp_outdir <- paste(window_outdir,i,"/contiguous/alignment/",sep="")
  if (!file.exists(temp_outdir)) {
    dir.create(temp_outdir, recursive = T)
  }
  
  treedir <- paste(window_outdir,i,"/contiguous/trees/",sep="")
  if (!file.exists(treedir)) {
    dir.create(treedir, recursive = T)
  }
  
  acount <- length(list.files(temp_outdir,pattern='fa'))
  tcount <- length(list.files(treedir,pattern='iqtree'))
  if (acount != 0 && tcount != 0 && !params$redo) {
    log4r::info(fn_logger, paste0("Files already exist: ", i, "bp contiguous window alignment and treefile. Skipped.", sep=""))
    next
  }
  
  # read annotation summary file
  smfile <- read.table(paste(window_outdir,i,"/summary/",params$prefix,".atsum", sep=""))
  colnames(smfile) <- smfile[1,]
  smfile <- smfile[-1,]
    
  unique_topology <- sort(unique(smfile$newick))
  newick_map <- data.frame(stringsAsFactors = FALSE)
  count <- 1
  
  # combine windows based on topology
  unlink(paste0(temp_outdir,"*.fa"))
  
  for (t in unique_topology) {
    sub_sw <- subset(smfile[smfile$newick == t,])
    align_idx <- unlist(Map(seq, sub_sw$start, sub_sw$stop))
        
    alignment <- sdf[,align_idx]
    subfasta <- setNames(split(alignment, seq(nrow(alignment))), rownames(alignment))
      
    write.fasta(sequences=subfasta, names=names(subfasta), file.out=paste(temp_outdir,"G",count,".fa",sep=""), nbchar = 100)
    newick_map <- rbind(newick_map, c(t, paste("G",count,sep="")))
    count <- count + 1
  }
    
  write.table(newick_map, paste(temp_outdir, "../", params$prefix, ".map", sep=""), quote = F, row.names = F, col.names = F)
  log4r::info(fn_logger, paste0("Files created: ", i, "bp contiguous window alignment files. File naming convention is available at ",
                               params$prefix, ".map.", sep=""))
    
  # generate contiguous window tree
  prefix <- paste(treedir, params$prefix, sep="")
  if (is.null(params$outgroup) || params$outgroup == ""){
    system(paste(params$iqtree2dir,"-S",temp_outdir,"-m",params$alisim_model,"-pre",prefix,"--quiet -redo", sep=" "))
  } else {
    system(paste(params$iqtree2dir,"-S",temp_outdir,"-m",params$alisim_model,"-pre",prefix,"--quiet -redo -o",params$outgroup, sep=" "))
  }
  
  log4r::info(fn_logger, paste0("File created: ", i, "bp contiguous window treefile.", sep=""))
}
```