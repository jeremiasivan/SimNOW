---
title: "Stepwise NOW for Empirical Dataset"
---

```{r nowsetup, include=FALSE}
write.table(c("",
              "####################################",
              "####         NOW Analysis       ####",
              "####################################"),
            file=fn_log, quote=F, row.names=F, col.names=F, append=T)

# output files
fn_summary <- paste0(getwd(), "/", params$prefix, ".sumtable")

# check input parameters
if (params$initial_wsize <= 0 || params$initial_wsize%%2 != 0) {
  log4r::error(fn_logger, "Error: invalid starting window size. Exited.")
}

if (!is.null(params$bootstrap_type) && params$bootstrap_type != "") {
  bs_type <- tolower(params$bootstrap_type)

  if (bs_type == "ufboot" && params$bootstrap < 1000) {
    log4r::error(fn_logger, "Error: invalid number of bootstrap for UFBoot. Exited.")
  } else if (bs_type == "nonparametric" && params$bootstrap < 100) {
    log4r::error(fn_logger, "Error: invalid number of bootstrap for non-parametric bootstrap. Exited.")
  }
}

min_branch_support <- 80
if (tolower(params$bootstrap_type) == "ufboot") {
  min_branch_support <- 95
}
```

```{r functions, include=FALSE}
f_window_aln <- function(fasta, start, end, dir_perwindow, j, wi) {
  subfasta <- lapply(fasta, function(x) x[seq(from = start, to = end)])
  subfasta <- do.call(rbind,subfasta)
  subfasta <- setNames(split(subfasta, seq(nrow(subfasta))), rownames(subfasta))
  
  window_name <- paste0("window_",formatC(j,width=wi,format="d",flag="0"))
  dir_window <- paste0(dir_perwindow, window_name, "/")
  if (!dir.exists(dir_window)) {
    dir.create(dir_window, recursive = T)
  }

  fn_out <- paste0(dir_window, window_name, ".fa")
  seqinr::write.fasta(sequences=subfasta, names=names(subfasta), file.out=fn_out, nbchar=100)

  return(c(fn_out, window_name))
}

iqtree2_single <- function(input, outgroup, setblmin, setmodel, dna_model, bs_type, bs, dir_iqtree2) {
  iqtree_cmd <- paste(dir_iqtree2,
                      "-s", input,
                      "-T 1 --quiet -redo")
  
  if (!is.null(outgroup) && !outgroup == ""){
    iqtree_cmd <- paste(iqtree_cmd, "-o", outgroup)
  }
  
  if (setblmin) {
    iqtree_cmd <- paste(iqtree_cmd, "-blmin", 1/i)
  }
  
  if (setmodel) {
    iqtree_cmd <- paste(iqtree_cmd, "-m", dna_model)
  }

  if (!is.null(bs_type) && bs_type != "") {
    if (tolower(bs_type) == "ufboot") {
      iqtree_cmd <- paste(iqtree_cmd, "-bb", bs)
    } else if (tolower(bs_type) == "nonparametric") {
      iqtree_cmd <- paste(iqtree_cmd, "-b", bs)
    }
  }
  
  system(iqtree_cmd)
}
```

```{r window-size, include=FALSE}
write.table(c("",
              "---------- Window Alignment --------"),
              file=fn_log, quote=F, row.names=F, col.names=F, append=T)

options(scipen=999)

# extract window sizes based on the initial size
max_wsize <- params$initial_wsize
wsizes <- max_wsize
while (max_wsize %% 2 == 0) {
  wsizes <- c(wsizes, max_wsize / 2)
  max_wsize <- max_wsize / 2
}
wsizes <- sort(wsizes, decreasing=T)

# set number of thread
stepthread <- params$thread
if (stepthread > length(wsizes)-1) {
  stepthread <- length(wsizes)-1
}

# read fasta file
s <- seqinr::read.fasta(params$input_aln, whole.header = T)

# remove empty sites
empty_columns <- which(s[[1]] == " ")
if (length(empty_columns) != 0) {
  s <- lapply(s, function(x) {x[-empty_columns]})
}

# get length of the alignment
s_ln <- seqinr::getLength(s)[1]
write.table(paste0("Number of sites: ", s_ln, "bp"),
            file=fn_log, quote=F, row.names=F, col.names=F, append=T)

# update the alignment to be divisible by the initial window size
s_ln_new <- floor(s_ln/params$initial_wsize) * params$initial_wsize

s <- lapply(s, function(x) x[seq(from = 1, to = s_ln_new)])
s <- do.call(rbind, s)
s <- setNames(split(s, seq(nrow(s))), rownames(s))
write.table(paste0("Updated number of sites: ", s_ln_new, "bp"),
            file=fn_log, quote=F, row.names=F, col.names=F, append=T)
```

```{r window-aln, include=FALSE}
options(scipen=999)

# create doSNOW cluster
nwcl <- makeCluster(stepthread)
doSNOW::registerDoSNOW(nwcl)

foreach (i = 2:length(wsizes)-1) %dopar% {
  df_long <- data.table::data.table(name=character(),start=numeric(),end=numeric(),is_informative=logical())
  df_short <- data.table::data.table()

  ########################################### LONG ############################################
  if (i == 1) {
    # create outdir
    dir_perwindow <- paste0(getwd(), "/", i, "/", wsizes[i], "/perwindow/")
    if (!dir.exists(dir_perwindow)) {
      dir.create(dir_perwindow, recursive = T)
    }

    # output file
    fn_long <- paste0(dir_perwindow, wsizes[i], ".perwindowsum")

    # check if files already exist
    numw <- s_ln_new/wsizes[i]
    if (length(list.files(dir_perwindow, pattern='fa')) == numw && !params$redo) {
      log4r::info(fn_logger, paste0("File found: ", wsizes[i], "bp window alignment."))

    } else {
      # remove all alignments in the folder
      unlink(paste0(dir_perwindow,"*.fa"))
      
      # generate window alignments
      start <- 1
      wi <- ceiling(log(numw) / log(10)) + 1
      
      for (j in 1:numw) {
        is_informative <- FALSE
        out <- f_window_aln(s, start, j*wsizes[i], dir_perwindow, j, wi)

        iqtree2_single(out[1], params$outgroup, params$set_blmin, params$set_model, params$dna_model, NULL, 0, params$iqtree2dir)
        if (file.exists(paste0(out[1],".treefile"))) {
          fn_iqtree <- paste0(out[1],".iqtree")
          len_informative_sites <- as.numeric(gsub("^.* ", "", system(paste("grep '^Number of parsimony informative sites'",fn_iqtree), intern = T)))

          if (len_informative_sites >= params$min_informative_sites) {
            is_informative <- TRUE
          }
        }

        df_long <- rbind(df_long, list(name=out[2],start=start,end=j*wsizes[i],is_informative=is_informative))
        start <- start + wsizes[i]
      }

      data.table::fwrite(df_long, fn_long, quote=FALSE, sep="\t")
    }
  }

  ########################################### SHORT ###########################################
  # create outdir
  dir_perwindow <- paste0(getwd(), "/", i, "/", wsizes[i+1], "/perwindow/")
  if (!dir.exists(dir_perwindow)) {
    dir.create(dir_perwindow, recursive = T)
  }

  # output file
  fn_short <- paste0(dir_perwindow, wsizes[i+1], ".perwindowsum")
  
  # check if files already exist
  numw <- s_ln_new/wsizes[i+1]
  if (length(list.files(dir_perwindow, pattern='fa')) == numw && !params$redo) {
    log4r::info(fn_logger, paste0("File found: ", wsizes[i+1], "bp window alignment."))
    return(NULL)
  }

  # remove all alignments in the folder
  unlink(paste0(dir_perwindow,"*.fa"))
  
  # generate window alignments
  start <- 1
  wi <- ceiling(log(numw) / log(10)) + 1
  
  for (j in 1:numw) {
    is_informative <- FALSE
    out <- f_window_aln(s, start, j*wsizes[i+1], dir_perwindow, j, wi)

    iqtree2_single(out[1], params$outgroup, params$set_blmin, params$set_model, params$dna_model, NULL, 0, params$iqtree2dir)
    if (file.exists(paste0(out[1],".treefile"))) {
      fn_iqtree <- paste0(out[1],".iqtree")
      len_informative_sites <- as.numeric(gsub("^.* ", "", system(paste("grep '^Number of parsimony informative sites'",fn_iqtree), intern = T)))

      if (len_informative_sites >= params$min_informative_sites) {
        is_informative <- TRUE
      }
    }

    df_short <- rbind(df_short, list(name=out[2],start=start,end=j*wsizes[i+1],is_informative=is_informative))
    start <- start + wsizes[i+1]
  }
  
  data.table::fwrite(df_short, fn_short, quote=FALSE, sep="\t")
  log4r::info(fn_logger, paste("File created: Step", i, "per-window alignments."))
}

rm(s)
stopCluster(nwcl)
```

```{r window-filter, include=FALSE}
# create doSNOW cluster
nwcl <- makeCluster(stepthread)
doSNOW::registerDoSNOW(nwcl)

foreach (i = 2:length(wsizes)-1) %dopar% {
  fn_long <- ""
  if (i == 1) {
    fn_long <- paste0(getwd(), "/", i, "/", wsizes[i], "/perwindow/", wsizes[i], ".perwindowsum")
  } else {
    fn_long <- paste0(getwd(), "/", i-1, "/", wsizes[i], "/perwindow/", wsizes[i], ".perwindowsum")
  }
  
  fn_short <- paste0(getwd(), "/", i, "/", wsizes[i+1], "/perwindow/", wsizes[i+1], ".perwindowsum")

  df_long <- data.table::fread(fn_long)
  df_short <- data.table::fread(fn_short)

  ########################################### LONG ############################################
  # check which window is uninformative
  long_uninformative_idx <- c()
  for (j in 1:nrow(df_short)) {
    if (!df_short$is_informative[j]) {
      uninformative_idx <- which(df_long$start <= df_short$start[j] & df_long$end >= df_short$end[j])
      long_uninformative_idx <- c(long_uninformative_idx, uninformative_idx)
    }
  }
  long_uninformative_idx <- unique(long_uninformative_idx)

  # create outdir
  long_path <- paste0(getwd(), "/", i, "/", wsizes[i], "/filtered/")
  if (!dir.exists(long_path)) {
    dir.create(long_path, recursive=TRUE)
  }

  # remove uninformative windows
  long_names <- df_long$name
  if (length(long_uninformative_idx) != 0){
    long_names <- df_long$name[-long_uninformative_idx]
  }

  # check if files already exist
  if (length(list.files(long_path, pattern='*.fa$', recursive=TRUE)) == length(long_names) && !params$redo) {
    log4r::info(fn_logger, paste0("File found: ", wsizes[i], "bp filtered windows for Step", i, "."))

  } else {
    # iteration to copy the alignment
    for (j in long_names) {
      fn_path <- NULL
      if (i == 1) {
        fn_path <- paste0(getwd(), "/", i, "/", wsizes[i], "/perwindow/", j, "/", j, ".fa")
      } else {
        fn_path <- paste0(getwd(), "/", i-1, "/", wsizes[i], "/perwindow/", j, "/", j, ".fa")
      }
      
      temp_path <- paste0(long_path, j, "/")
      if (!dir.exists(temp_path)) {
        dir.create(temp_path)
      }

      system(paste("cp", fn_path, temp_path))
    }
  }

  ########################################### SHORT ###########################################
  # check which window is uninformative
  short_uninformative_idx <- c()
  for (j in long_uninformative_idx) {
    uninformative_idx <- which(df_short$start >= df_long$start[j] & df_short$end <= df_long$end[j])
    short_uninformative_idx <- c(short_uninformative_idx, uninformative_idx)
  }
  short_uninformative_idx <- unique(short_uninformative_idx)

  # create outdir
  short_path <- paste0(getwd(), "/", i, "/", wsizes[i+1], "/filtered/")
  if (!dir.exists(short_path)) {
    dir.create(short_path, recursive=TRUE)
  }

  # remove uninformative windows
  short_names <- df_short$name
  if (length(short_uninformative_idx) != 0){
    short_names <- df_short$name[-short_uninformative_idx]
  }

  # check if files already exist
  if (length(list.files(short_path, pattern='*.fa$', recursive=TRUE)) == length(short_names) && !params$redo) {
    log4r::info(fn_logger, paste0("File found: ", wsizes[i+1], "bp filtered windows for Step", i, "."))
    return(NULL)
  }

  # iteration to copy the alignment
  for (j in short_names) {
    fn_path <- paste0(getwd(), "/", i, "/", wsizes[i+1], "/perwindow/", j, "/", j, ".fa")

    temp_path <- paste0(short_path, j, "/")
    if (!dir.exists(temp_path)) {
      dir.create(temp_path)
    }

    system(paste("cp", fn_path, temp_path))
  }

  log4r::info(fn_logger, paste("File created: Step", i, "window filtering."))
}

stopCluster(nwcl)
```

```{r window-tree, include=FALSE}
write.table(c("",
              "------------ Window Tree -----------"),
              file=fn_log, quote=F, row.names=F, col.names=F, append=T)

options(scipen=999)

# create doSNOW cluster
nwcl <- makeCluster(params$thread)
doSNOW::registerDoSNOW(nwcl)

# iterate through window sizes
for (i in 2:length(wsizes)-1) {
  ########################################### LONG ############################################
  long_path <- paste0(getwd(), "/", i, "/", wsizes[i], "/filtered/")

  # check input alignments
  dirs <- list.dirs(long_path, full.names = F, recursive = F)
  dirs <- dirs[grepl("^window", dirs)]
  
  foreach (j = dirs) %dopar% {
    windowdir <- paste0(long_path, j, "/")
    fastadir <- paste0(windowdir, j, ".fa")

    # check if files exist
    iqtreefile <- paste0(windowdir, j, ".fa.iqtree")
    treefile <- paste0(windowdir, j, ".fa.treefile")
    if (all(file.exists(iqtreefile, treefile)) && !params$redo) {
      return(NULL)
    }
    
    iqtreefile <- paste0(getwd(), "/", i-1, "/", wsizes[i], "/filtered/", j, "/", j, ".fa.iqtree")
    treefile <- paste0(getwd(), "/", i-1, "/", wsizes[i], "/filtered/", j, "/", j, ".fa.treefile")
    if (all(file.exists(iqtreefile, treefile))) {
      system(paste("cp", iqtreefile, windowdir))
      system(paste("cp", treefile, windowdir))
    } else {
      iqtree2_single(fastadir, params$outgroup, params$set_blmin, params$set_model, params$dna_model, params$bootstrap_type, params$bootstrap, params$iqtree2dir)
    }
  }

  ########################################### SHORT ###########################################
  short_path <- paste0(getwd(), "/", i, "/", wsizes[i+1], "/filtered/")

  # check input alignments
  dirs <- list.dirs(short_path, full.names = F, recursive = F)
  dirs <- dirs[grepl("^window", dirs)]
  
  foreach (j = dirs) %dopar% {
    fastadir <- paste0(short_path, j, "/", j, ".fa")

    iqtreefile <- paste0(short_path, j, "/", j, ".fa.iqtree")
    treefile <- paste0(short_path, j, "/", j, ".fa.treefile")
    if (all(file.exists(iqtreefile, treefile)) && !params$redo) {
      return(NULL)
    }

    iqtree2_single(fastadir, params$outgroup, params$set_blmin, params$set_model, params$dna_model, params$bootstrap_type, params$bootstrap, params$iqtree2dir)
  }

  log4r::info(fn_logger, paste("File created: Step", i, "window treefile."))
}
```

```{r nowsummary, include=FALSE}
options(scipen=999)

df_output <- data.table::data.table(step=numeric(),
                        l_wsize=numeric(), s_wsize=numeric(),
                        l_aic=numeric(), s_aic=numeric(), diff_aic=numeric(),
                        fasta_ln=numeric(), fasta_ln_percent=numeric(),
                        l_bs_tree=numeric(), l_bs_topology=numeric(), s_bs_tree=numeric(), s_bs_topology=numeric()
                        )

# create doSNOW cluster
nwcl <- makeCluster(params$thread)
doSNOW::registerDoSNOW(nwcl)

# iterate through window sizes
for (i in 2:length(wsizes)-1) {
  ########################################### LONG ############################################
  long_path <- paste0(getwd(), "/", i, "/", wsizes[i], "/filtered/")
  dirs <- list.dirs(long_path, full.names = F, recursive = F)
  dirs <- dirs[grepl("^window", dirs)]

  long_output <- foreach(j = dirs, .combine=c) %dopar% {
    iqtree_path <- paste0(long_path, j, "/", j, ".fa.iqtree")
    treefile_path <- paste0(long_path, j, "/", j, ".fa.treefile")

    if (!all(file.exists(iqtree_path, treefile_path))) {
      log4r::warn(fn_logger, paste0("File not found: .treefile or .iqtree for ", j, " in Step ", i, ". Copying from perwindow result."))

      if (i == 1) {
        iqtree_path <- paste0(getwd(), "/", i, "/", wsizes[i], "/perwindow/", j, "/", j, ".fa.iqtree")
        treefile_path <- paste0(getwd(), "/", i, "/", wsizes[i], "/perwindow/", j, "/", j, ".fa.treefile")
      } else {
        iqtree_path <- paste0(getwd(), "/", i-1, "/", wsizes[i], "/perwindow/", j, "/", j, ".fa.iqtree")
        treefile_path <- paste0(getwd(), "/", i-1, "/", wsizes[i], "/perwindow/", j, "/", j, ".fa.treefile")
      }
    }

    # extract log-likelihood and number of free parameters
    logl <- gsub(" \\(.*\\)$", "", system(paste("grep '^Log-likelihood of the tree'",iqtree_path), intern = T))
    logl <- as.numeric(gsub("^.* ", "", logl))
    freeparams <- as.numeric(gsub("^.* ", "", system(paste("grep '^Number of free parameters'",iqtree_path), intern = T)))
    
    # read treefile
    tre <- readLines(treefile_path)

    tl <- ape::read.tree(text=tre)
    tl$edge.length <- NULL

    if (!is.null(params$bootstrap_type) && params$bootstrap_type != "") {
      bl <- subset(tl$node.label, tl$node.label != "")

      if (!is.null(bl) && mean(as.numeric(bl)) >= min_branch_support) {
        tl$node.label <- NULL
        return(list(list(logl, freeparams, ape::write.tree(tl))))
      }
    }
    
    return(list(list(logl, freeparams, NULL)))
  }

  long_logl <- sum(sapply(long_output, function(x) x[[1]]))
  long_freeparams <- sum(sapply(long_output, function(x) x[[2]]))
  long_aic <- (2 * long_freeparams) - (2 * long_logl)

  long_tree <- unlist(sapply(long_output, function(x) {x[[3]]}))
  s_ln_step <- length(dirs) * wsizes[i]

  # calculate the topology distribution
  fn_uqtops <- paste0(getwd(), "/", i, "/", wsizes[i], "/", wsizes[i], ".uqtops")

  df_topology <- data.table::as.data.table(long_tree)
  data.table::setnames(df_topology, "topology")
  sorted_topology <- df_topology %>%
    group_by(topology) %>%
    summarise(n = n()) %>%
    arrange(desc(n)) %>%
    mutate(cum.percentage=round(cumsum(n)/sum(n)*100,3))
  data.table::fwrite(sorted_topology, file=fn_uqtops, quote=F, sep="\t")

  ########################################### SHORT ###########################################
  short_path <- paste0(getwd(), "/", i, "/", wsizes[i+1], "/filtered/")
  dirs <- list.dirs(short_path, full.names = F, recursive = F)
  dirs <- dirs[grepl("^window", dirs)]

  if (s_ln_step != length(dirs) * wsizes[i+1]) {
    log4r::error(fn_logger, paste0("Error: different alignment lengths on Step", i, "."))
  }

  short_output <- foreach(j = dirs, .combine=c) %dopar% {
    iqtree_path <- paste0(short_path, j, "/", j, ".fa.iqtree")
    treefile_path <- paste0(short_path, j, "/", j, ".fa.treefile")

    if (!all(file.exists(iqtree_path, treefile_path))) {
      log4r::warn(fn_logger, paste0("File not found: .treefile or .iqtree for ", j, " in Step ", i, ". Copying from perwindow result."))

      iqtree_path <- paste0(getwd(), "/", i, "/", wsizes[i+1], "/perwindow/", j, "/", j, ".fa.iqtree")
      treefile_path <- paste0(getwd(), "/", i, "/", wsizes[i+1], "/perwindow/", j, "/", j, ".fa.treefile")
    }

    # extract log-likelihood and number of free parameters
    logl <- gsub(" \\(.*\\)$", "", system(paste("grep '^Log-likelihood of the tree'",iqtree_path), intern = T))
    logl <- as.numeric(gsub("^.* ", "", logl))
    freeparams <- as.numeric(gsub("^.* ", "", system(paste("grep '^Number of free parameters'",iqtree_path), intern = T)))
    
    # read treefile
    tre <- readLines(treefile_path)

    tl <- ape::read.tree(text=tre)
    tl$edge.length <- NULL

    if (!is.null(params$bootstrap_type) && params$bootstrap_type != "") {
      bl <- subset(tl$node.label, tl$node.label != "")

      if (!is.null(bl) && mean(as.numeric(bl)) >= min_branch_support) {
        tl$node.label <- NULL
        return(list(list(logl, freeparams, ape::write.tree(tl))))
      }
    }
    
    return(list(list(logl, freeparams, NULL)))
  }

  short_logl <- sum(sapply(short_output, function(x) x[[1]]))
  short_freeparams <- sum(sapply(short_output, function(x) x[[2]]))
  short_aic <- (2 * short_freeparams) - (2 * short_logl)

  short_tree <- unlist(sapply(short_output, function(x) {x[[3]]}))

  # calculate the topology distribution
  fn_uqtops <- paste0(getwd(), "/", i, "/", wsizes[i+1], "/", wsizes[i+1], ".uqtops")

  df_topology <- data.table::as.data.table(short_tree)
  data.table::setnames(df_topology, "topology")
  sorted_topology <- df_topology %>%
    group_by(topology) %>%
    summarise(n = n()) %>%
    arrange(desc(n)) %>%
    mutate(cum.percentage=round(cumsum(n)/sum(n)*100,3))
  data.table::fwrite(sorted_topology, file=fn_uqtops, quote=F, sep="\t")

  ########################################## SUMMARY ##########################################
  df_output <- rbind(df_output,
                    list(step=i,l_wsize=wsizes[i],s_wsize=wsizes[i+1],
                        l_aic=long_aic, s_aic=short_aic, diff_aic=short_aic-long_aic,
                        fasta_ln=s_ln_step, fasta_ln_percent=round((s_ln_step/s_ln)*100,3),
                        l_bs_tree=length(long_tree), l_bs_topology=length(unique(long_tree)),
                        s_bs_tree=length(short_tree), s_bs_topology=length(unique(short_tree))),
                    fill=TRUE)
  log4r::info(fn_logger, paste0("Summary added: Step ", i, "."))
}

stopCluster(nwcl)

data.table::fwrite(df_output, fn_summary, quote=FALSE, sep="\t")
log4r::info(fn_logger, "File created: summary file.")
```